# Python 
#import os
from datetime import datetime
from functools import partial
# LangChain
from langchain.schema.runnable import RunnableLambda

# Cassandra
#from cassandra.cluster import Cluster
#from cassandra.query import SimpleStatement
from cassandra.util import uuid_from_time

# Other
from base32_crockford import encode as crockford_encode, decode as crockford_decode

################################################################################
## Cassandra Methods

def get_next_conversation_id(session) -> str:
    """
    Queries the conversation_users table to find the maximum conversation id,
    increments it (as an integer), and returns the new conversation id in Crockford base32 format.
    Assumes conversation_id is stored as text in the format "cid=<value>".
    """
    query = "SELECT DISTINCT conversation_id FROM conversation_users"
    rows = session.execute(query)

    max_value = -1
    for row in rows:
        conv_id = row.conversation_id  # e.g. "cid=0"
        if conv_id.startswith("cid="):
            num_part = conv_id[4:]
        else:
            num_part = conv_id
        try:
            # Convert the Crockford base32 string to an integer.
            value = crockford_decode(num_part.upper())
            if value > max_value:
                max_value = value
        except Exception as e:
            print(f"Error converting conversation id '{conv_id}': {e}")
    
    new_value = max_value + 1
    new_conv_id = "cid=" + crockford_encode(new_value)
    return new_conv_id

def create_new_conversation(session, participants: list) -> str:
    """
    Creates a new conversation by:
      1. Determining the next conversation ID.
      2. Inserting records into:
         - conversation_users: linking conversation_id with each participant.
         - user_conversations: linking each participant with conversation_id and a current timestamp.
         - conversation_messages: inserting an initial system message.
         
    Args:
        session: Cassandra session connected to your keyspace.
        participants: List of user IDs (strings) that will participate in the conversation.
        
    Returns:
        The new conversation ID as a string.
    """
    new_conv_id = get_next_conversation_id(session)
    now = datetime.utcnow()

    # Prepare statements for each table.
    insert_conv_user = session.prepare("""
        INSERT INTO conversation_users (conversation_id, user_id)
        VALUES (?, ?)
    """)
    
    insert_user_conv = session.prepare("""
        INSERT INTO user_conversations (user_id, conversation_id, last_updated)
        VALUES (?, ?, ?)
    """)
    
    # For conversation_messages we use a system message with a timeuuid generated by now() in CQL.
    # Note: The CQL function now() returns a timeuuid.
    insert_conv_msg = session.prepare("""
        INSERT INTO conversation_messages (conversation_id, message_time, sender_id, message)
        VALUES (?, now(), ?, ?)
    """)

    # Insert a record in conversation_users and user_conversations for each participant.
    for user_id in participants:
        session.execute(insert_conv_user, (new_conv_id, user_id))
        session.execute(insert_user_conv, (user_id, new_conv_id, now))
    
    # Insert an initial system message in conversation_messages.
    system_message = "Conversation created at " + now.isoformat() + " UTC"
    session.execute(insert_conv_msg, (new_conv_id, "system", system_message))
    
    return new_conv_id

def DBReadMessagesCass(session, conversation_id: str, n: int) -> list:
    """
    Reads the most recent n messages from the conversation_messages table for the given conversation.
    
    Args:
        session: Cassandra session connected to your keyspace.
        conversation_id (str): The conversation ID (e.g., "cid=1").
        n (int): The number of most recent messages to retrieve.
    
    Returns:
        A list of dictionaries, each containing:
          - conversation_id (str)
          - message_time (timeuuid)
          - sender_id (str)
          - message (str)
          - human_readable (timestamp as string, using the dateof() function)
    """
    # Note: Even though the table might be defined with clustering order ASC,
    # you can override the order in your query to get the most recent messages first.
    query = """
      SELECT conversation_id, message_time, sender_id, message, dateof(message_time) as message_timestamp 
      FROM conversation_messages 
      WHERE conversation_id = %s 
      ORDER BY message_time DESC 
      LIMIT %s
    """
    rows = session.execute(query, (conversation_id, n))
    
    results = []
    for row in rows:
        results.insert(0,{
            "conversation_id": row.conversation_id,
            "message_time": str(row.message_time),
            "sender_id": row.sender_id,
            "message": row.message,
            "message_timestamp": row.message_timestamp.strftime("%Y-%m-%d %H:%M:%S") if row.message_timestamp else None
        }) # Insert at the beginning of the list so that the oldest messages are on top
    return results

def DBAddMessageCass(RunningState, session, conversation_id: str, sender_id: str, message: str, timestamp: datetime):
    """
    Inserts a new message into conversation_messages using a timeuuid generated from the given timestamp.
    Waits for the DB to confirm insertion before returning.
    
    Args:
        session: Cassandra session connected to your keyspace.
        conversation_id (str): The conversation ID (e.g., "cid=1").
        sender_id (str): The sender's user id.
        message (str): The message text.
        timestamp (datetime): A datetime object representing when the message was sent.
    
    Returns:
        The generated timeuuid for the message.
    """
    # Generate a timeuuid from the provided timestamp.
    time_uuid = uuid_from_time(timestamp)
    
    # Prepare the INSERT statement.
    insert_stmt = session.prepare("""
        INSERT INTO conversation_messages (conversation_id, message_time, sender_id, message)
        VALUES (?, ?, ?, ?)
    """)
    
    # Execute the statement and wait for confirmation.
    session.execute(insert_stmt, (conversation_id, time_uuid, sender_id, message))
    return RunningState

def DBGetUserInfo(session, uids: str | list) -> dict:
    """
    Retrieves user records from the users table by their user IDs.
    
    Args:
        session: Cassandra session connected to your keyspace.
        uids: Either a single user ID (str) or a list of dictionaries with 'user_id' keys.
    
    Returns:
        A dictionary representing the user record(s), or None if not found.
    """
    # Convert single uid to list for consistent processing
    if isinstance(uids, str):
        uid_list = [uids]
    else:
        # Extract user_ids from the list of dictionaries
        uid_list = [uid['user_id'] for uid in uids]
    
    # Use proper CQL syntax for IN clause with multiple placeholders
    placeholders = ','.join(['%s'] * len(uid_list))
    query = f"SELECT uid, preferred_name, name, phonetic_ja, phonetic_en, gender, preflang, ai, pronouns, bio FROM users WHERE uid IN ({placeholders})"
    
    # Execute with the list of values directly
    rows = session.execute(query, uid_list)
    
    # Convert all rows to a list of dictionaries
    results = []
    for row in rows:
        results.append(dict(row._asdict()))
    
    # Return single dict if only one result, otherwise return list
    return results[0] if len(results) == 1 else results

def DBGetUserByLineId(session, lineid: str) -> dict:
    """
    Retrieves a user record from the users table by its LineId.
    
    Args:
        session: Cassandra session connected to your keyspace.
        lineid (str): The LineId value to search for.
    
    Returns:
        A dictionary representing the user record, or None if not found.
    """
    # If LineId is not part of the primary key, you need an index:
    # CREATE INDEX ON users(LineId);
    query = "SELECT uid, active_conversation FROM users WHERE LineId = %s"
    rows = session.execute(query, (lineid,))
    for row in rows:
        # Convert the row to a dictionary. Depending on your driver version, 
        # you might be able to use row._asdict() or dict(row)
        return dict(row._asdict())
    return None

def DBGetUsersByConvoId(session, cid: str) -> list:
    """
    Retrieves a list of user records from the users table by its conversation ID.
    
    Args:
        session: Cassandra session connected to your keyspace.
        cid (str): The conversation ID (e.g., "cid=1").
    
    Returns:
        A dictionary representing the user record, or None if not found.
    """
    # If LineId is not part of the primary key, you need an index:
    # CREATE INDEX ON users(LineId);
    query = "SELECT user_id FROM conversation_users WHERE conversation_id = %s"
    rows = session.execute(query, (cid,))
    results = []
    for row in rows:
        # Convert the row to a dictionary. Depending on your driver version, 
        # you might be able to use row._asdict() or dict(row)
        results.append(dict(row._asdict()))
    return results

################################################################################
## LangChain Runnables


def RReadMessages(session):
    """
    Returns a RunnableLambda that, when invoked with conversation_id and n (number of messages),
    reads and returns the most recent n messages for that conversation.
    
    Usage:
      rread = get_RReadMessages(session)
      messages = rread.invoke("cid=1", 5)
    """
    return RunnableLambda(lambda conversation_id, n: DBReadMessagesCass(session, conversation_id, n))



def RAddMessage(session, conversation_id, sender_id, message, timestamp):
    """
    Returns a RunnableLambda that, when invoked with conversation_id, sender_id, message, and timestamp,
    adds a new message to the conversation_messages table.
    
    Args can be either direct values or lambda functions that take the chain state and return the value.
    
    Usage:
        radd = RAddMessage(session, "cid=1", "uid=99", "Hello!", datetime.utcnow())
        # Or with lambda functions:
        radd = RAddMessage(
            session=session,
            conversation_id=lambda x: x["conversation_id"],
            sender_id=lambda x: x["sender_id"],
            message=lambda x: x["message"],
            timestamp=lambda x: x["timestamp"]
        )
    
    Returns:
        A RunnableLambda instance.
    """
    def _add_message(x):
        # Get values, either by calling lambda or using direct value
        conv_id = conversation_id(x) if callable(conversation_id) else conversation_id
        send_id = sender_id(x) if callable(sender_id) else sender_id
        msg = message(x) if callable(message) else message
        ts = timestamp(x) if callable(timestamp) else timestamp
        
        return DBAddMessageCass(x, session, conv_id, send_id, msg, ts)
    
    return RunnableLambda(_add_message)


